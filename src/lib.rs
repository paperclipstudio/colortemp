//! A simple crate that calculates color temperatures
//!
//! It implements an algorithm by Tanner Helland that calculates
//! RGB values for specific color temperatures. It can also do
//! the inverse by aproxmiation.
//!
//! Source can be found at [[https://tannerhelland.com/2012/09/18/convert-temperature-rgb-algorithm-code.html]]
//!
//! This crate includes unit tests to ensure functionality
//!
//! ## Examples
//!
//! Following are some simple examples of how to use this crate
//!
//! ```rust
//! extern crate colortemp;
//!
//! let mut rgb = colortemp::temp_to_rgb(2000);
//! println!("{:?}", rgb);
//! ```
//!
//! The values generated by this crate can include uncertainty
//! and might therefore not be suitable for scientific computing.
//!
//! If you wish to change this, PR's are always welcome ðŸ˜

pub use colortemp::*;
mod colortemp {
    use std::ops::{Mul, Sub};

    /// A simple container format to describe an RGB value
    #[derive(Debug, PartialEq)]
    pub struct RGB {
        pub r: f64,
        pub g: f64,
        pub b: f64,
    }

    // Calculate the RGB value of a color temperature (in Kelvin)
    pub fn temp_to_rgb(kelvin: u64) -> RGB {
        let temp = kelvin / 100;
        /* Calculate red */
        let r = match temp {
            (..66) => 255.0,
            (66..) => (temp as f64)
                .sub(60.0)
                .powf(-0.1332047592)
                .clamp(0.0, 255.0),
        };

        let g = match temp {
            (..67) => (temp as f64).ln().mul(99.4708025861).sub(161.1195681661),
            (67..) => (temp as f64)
                .sub(60.0)
                .powf(-0.0755148492)
                .mul(288.1221695283),
        }
        .clamp(0.0, 255.0)
        .round();

        let b = match temp {
            (..20) => 0.0,
            (20..66) => (temp as f64)
                .sub(10.0)
                .ln()
                .mul(38.5177312231)
                .sub(305.0447927307)
                .clamp(0.0, 255.0),
            (66..) => 255.0,
        }
        .round();

        RGB { r: r.round(), g, b }
    }

    /// Calculates the color temperature for a given RGB value
    ///
    /// This is implemented via a reverse lookup onto @temperature_to_rgb and
    /// as such should be considered rather slow
    ///
    pub fn rgb_to_temp(col: RGB) -> u64 {
        let (r, b) = (col.r, col.b);

        let mut temp = 0;
        let mut test_rgb;

        let epsilon = 2.;
        let (mut min, mut max) = (1000, 40000);

        while (max as f64) - (min as f64) > epsilon {
            temp = (max + min) / 2;
            test_rgb = temp_to_rgb(temp);
            if (test_rgb.b / test_rgb.r) >= (b / r) {
                max = temp;
            } else {
                min = temp;
            }
        }

        temp
    }
}
